<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fatigue Test</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 0;
    }


    .page {
      display: none;
      background: white;
      padding: 40px 30px;
      max-width: 1200px; 
      width: 90%;
      margin: 20px auto; 
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      animation: fadeIn 0.4s ease;
    }
    .page.active { display: block; }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* --- HEADER LOGOS --- */
    .header-logos {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    .header-logos img { height: 60px; }

    /* --- PAGE IDENTIFICATION --- */
    #identify h1,
    #identify p {
    text-align: center;
    }

    #identify .identify-form {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-top: 25px;
    }


    /* --- PAGE ACCUEIL --- */
    #home { text-align: center; }

    .title { font-size: 36px; margin-bottom: 20px; }

    .center-image {
      width: 80%;
      max-width: 400px;
      margin: 0 auto 30px auto;
      display: block;
    }

    .start-button {
      font-size: 24px;
      padding: 15px 40px;
      background-color: #d32f2f;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
    }

    .start-button:hover { background-color: #b71c1c; }

    /* --- PAGE QUESTIONS --- */
    #questionText { font-size: 26px; margin-bottom: 15px; white-space: pre-line; }

    /* --- SCENARIO LAYOUT (title+image left, description+prompt right) --- */
    #scenarioWrap { display: none; margin-bottom: 12px; }
    #scenarioGrid {
      display: grid;
      grid-template-columns: minmax(220px, 340px) 1fr;
      gap: 14px;
      align-items: start;
    }
    #scenarioLeft { display: flex; flex-direction: column; gap: 10px; }
    #scenarioTitle { font-size: 26px; margin: 0; white-space: pre-line; }
    #scenarioImage {
      display: none;
      width: 100%;
      border-radius: 12px;
      object-fit: cover;
      background: #111;
      max-height: 240px;
    }
    #scenarioRight { display: flex; flex-direction: column; gap: 10px; }
    #scenarioDescription {
      margin: 0;
      font-size: 18px;
      line-height: 1.45;
      white-space: pre-line;
      color: #222;
      text-align: justify;
    }
    #scenarioRulesPrompt {
      display: none;
      margin: 0;
      font-weight: 800;
      color: #333;
    }
    @media (max-width: 820px) {
      #scenarioGrid { grid-template-columns: 1fr; }
      #scenarioImage { max-height: none; }
    }

    /* --- RESULTS CHARTS --- */
    #chartsWrap { grid-template-columns: 1fr; }
    #chartsWrap .chart-card {
      padding: 12px;
      border: 1px solid #eee;
      border-radius: 12px;
      background: #fff;
      height: 260px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: hidden;
    }
    #chartsWrap .chart-card h3 { margin: 0; }
    #chartsWrap .chart-canvas { position: relative; flex: 1; min-height: 0; overflow: hidden; }
    #chartsWrap .chart-canvas canvas { display: block; width: 100% !important; max-height: 100% !important; }

    /* --- QCM validate button (match arrow button style) --- */
    .validate-button {
      width: 50px;
      height: 50px;
      font-size: 24px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
      align-self: flex-end;
    }
    .validate-button:hover:not(:disabled) {
      background-color: #0d47a1;
      transform: scale(1.1);
    }
    .validate-button:disabled {
      background-color: #aaa;
      cursor: not-allowed;
      transform: none;
    }

    /* --- DETAILS PAGE --- */
    .details-content {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 14px;
      align-items: stretch;
    }
    @media (max-width: 980px) {
      .details-content { grid-template-columns: 1fr; }
    }

    .details-column {
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      background: #f3f4f6;
      display: flex;
      flex-direction: column;
    }
    @media (min-width: 981px) {
      .details-column {
        min-height: 320px;
      }
    }
    .details-column h3,
    .details-column h4 {
      color: #1976d2;
    }
    .details-column h3 { margin-top: 0; }
    .details-dot {
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.12);
      cursor: pointer;
      font-weight: 800;
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.15s ease, opacity 0.15s ease, box-shadow 0.15s ease;
      user-select: none;
    }
    .details-dot:hover { transform: scale(1.05); }
    .details-dot.selected {
      opacity: 0.65;
      box-shadow: 0 0 0 4px rgba(25,118,210,0.12);
    }

    /* --- HOME HISTORY LAYOUT (chart left, list right scrollable) --- */
    #historyLayout {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 14px;
      margin-top: 14px;
      align-items: start;
    }
    @media (max-width: 980px) {
      #historyLayout { grid-template-columns: 1fr; }
    }
    #historyTableWrapper {
      max-height: 280px;
      overflow-y: auto;
      border-radius: 12px;
    }

    #questionImage {
      display: none;
      max-width: 100%;
      margin-bottom: 20px;
      border-radius: 8px;
    }

    .progress-container { margin-bottom: 20px; }

    #questionCounter { font-size: 14px; color: #555; }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 5px;
    }

    #progressFill {
      height: 100%;
      width: 0%;
      background: #1976d2;
      transition: width 0.4s ease;
    }

    .answer-row {
      display: flex;
      align-items: flex-end;
      gap: 10px;
    }

    textarea {
      flex: 1;
      height: 70px;
      font-size: 16px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
      resize: none;
    }

    .arrow-button {
      width: 50px;
      height: 50px;
      font-size: 24px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
    }

    .arrow-button:hover:not(:disabled) {
      background-color: #0d47a1;
      transform: scale(1.1);
    }

    .arrow-button:disabled {
      background-color: #aaa;
      cursor: not-allowed;
      transform: none;
    }

    /* --- PAGE FIN --- */
    .finish-button {
      padding: 15px 40px;
      font-size: 20px;
      background-color: #b71c1c;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
    }

    .finish-button:hover { background-color: #1b5e20; }

    /* --- LOADING OVERLAY --- */
    .loading-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(245,245,245,0.8);
      backdrop-filter: blur(2px);
      z-index: 9999;
    }

    .loading-overlay.active { display: flex; }

    .loading-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 22px 26px;
      border-radius: 16px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 8px 28px rgba(0,0,0,0.12);
    }

    .spinner {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: conic-gradient(from 180deg, #1976d2, #42a5f5, #90caf9, #1976d2);
      -webkit-mask: radial-gradient(farthest-side, transparent 62%, #000 63%);
      mask: radial-gradient(farthest-side, transparent 62%, #000 63%);
      animation: spin 0.9s linear infinite;
    }

    .loading-text {
      font-size: 14px;
      color: #333;
      letter-spacing: 0.2px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* --- SMALL GRADING INDICATOR (bottom-right) --- */
    .grading-indicator {
      position: fixed;
      right: 16px;
      bottom: 16px;
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.95);
      border-radius: 999px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
      z-index: 10000;
      font-size: 12px;
      color: #333;
    }

    .grading-indicator.active { display: flex; }

    .spinner-sm {
      width: 18px;
      height: 18px;
      border: 3px solid #cfd8dc;
      border-top-color: #1976d2;
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
    }

    /* --- CAMERA SETUP --- */
    .camera-wrap {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
      margin-top: 18px;
    }

    .camera-video {
      width: 100%;
      max-height: 360px;
      background: #111;
      border-radius: 12px;
      object-fit: cover;
    }

    .camera-row {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    select {
      font-size: 14px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
      min-width: 280px;
      max-width: 100%;
    }

    /* --- QCM --- */
    .qcm-container {
    display: none;
    flex-direction: column;
    gap: 12px;
    margin-top: 20px;
    }

    .qcm-choice {
    display: flex;
    align-items: center;
    padding: 15px 20px;
    background: #f8f9fa;
    border: 2px solid #ddd;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 16px;
    }

    .qcm-choice:hover {
    background: #e3f2fd;
    border-color: #1976d2;
    }

    .qcm-choice.selected {
    background: #1976d2;
    border-color: #1976d2;
    color: white;
    }

    .choice-letter {
    width: 32px;
    height: 32px;
    background: #1976d2;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 15px;
    font-weight: bold;
    }

    .qcm-choice.selected .choice-letter {
    background: white;
    color: #1976d2;
    }

    /* --- Badge type question --- */
    .question-type-badge {
    display: inline-block;
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    margin-bottom: 10px;
    }

    .badge-qcm {
    background: #e3f2fd;
    color: #1976d2;
    }

    .badge-open {
    background: #fff3e0;
    color: #e65100;
    }

    .history-container {
      margin-top: 30px;
      overflow-x: auto;
    }

    .history-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }

    .history-table th,
    .history-table td {
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
      text-align: center;
      font-size: 15px;
    }

    .history-table th {
      background: #f5f5f5;
      font-weight: bold;
    }

    .result-apte { color: #2e7d32; font-weight: bold; }
    .result-attention { color: #f9a825; font-weight: bold; }
    .result-inapte { color: #c62828; font-weight: bold; }

    .start-test-container {
      position: fixed;
      right: 30px;
      bottom: 30px;
    }

    @media (min-width: 900px) {
      #chartsWrap {
        grid-template-columns: 1fr 1fr !important;
      }
    }


  </style>
</head>

<body>

<!-- LOADING OVERLAY -->
<div id="loading" class="loading-overlay" aria-hidden="true">
  <div class="loading-card" role="status" aria-live="polite">
    <div class="spinner" aria-label="Loading"></div>
    <div id="loadingText" class="loading-text"></div>
  </div>
</div>

<!-- SMALL GRADING INDICATOR -->
<div id="gradingIndicator" class="grading-indicator" aria-hidden="true">
  <div class="spinner-sm" aria-label="Grading in progress"></div>
  <div>Grading in progress…</div>
</div>

<!-- PAGE IDENTIFICATION -->
<div id="identify" class="page active">
  <div class="header-logos">
    <img src="{{ url_for('static', filename='logo-crossing.png') }}">
    <img src="{{ url_for('static', filename='logo-UT.png') }}">
  </div>

  <h1 class="title">Login</h1>
  <p>Enter your name to start.</p>

  <div class="identify-form">
        <input id="nameInput" type="text" placeholder="Your name"
           style="font-size:16px; padding:10px; border-radius:8px; border:1px solid #ccc; width: 60%; max-width: 360px;" />
        <button class="start-button" style="font-size:16px; padding:10px 18px;" onclick="confirmName()">Continue</button>
  </div>
  
</div>

<!-- PAGE ACCUEIL -->
<div id="home" class="page">
  <div class="header-logos">
    <img src="{{ url_for('static', filename='logo-crossing.png') }}">
    <img src="{{ url_for('static', filename='logo-UT.png') }}">
  </div>

  <h1 class="title">Your dashboard</h1>
  <p>Your test history</p>

  <div style="display:flex; justify-content:center; gap:14px; align-items:center; flex-wrap:wrap; margin-top: 10px;">
    <label style="font-size:14px; color:#333;">
      <input type="radio" name="compareMode" value="me" checked>
      My history
    </label>
    <label style="font-size:14px; color:#333;">
      <input type="radio" name="compareMode" value="others">
      Compare to others
    </label>
  </div>

  <!-- Historique -->
  <div id="historyContainer" class="history-container">

    <div id="historyLayout">
      <div id="historyChartWrap" style="padding:12px; border:1px solid #eee; border-radius:12px; background:#fff;">
        <h3 style="margin-top:0;">Score trends</h3>
        <canvas id="historyChart" height="180"></canvas>
        <div id="historyChartHint" style="margin-top:8px; font-size:12px; color:#666;"></div>
      </div>

      <!-- Tableau (scrollable) -->
      <div id="historyTableWrapper" style="display:none; padding:12px; border:1px solid #eee; border-radius:12px; background:#fff;">
        <h3 style="margin-top:0;">Sessions</h3>
        <table id="historyTable" class="history-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Mental fatigue</th>
              <th>Physical fatigue</th>
            </tr>
          </thead>
          <tbody id="historyTableBody">
            <!-- rempli en JS -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- Message si vide -->
    <div id="noHistoryMessage" class="no-history-message" style="display:none; text-align:center; margin-top:40px; font-size:18px; color:#666;">
      No history yet.<br>
      Click “Start a new test” to begin.
    </div>

  </div>

  <!-- Bouton nouveau test -->
  <div class="start-test-container">
    <button class="start-button" onclick="startTest()">
      Start a new test
    </button>
  </div>
</div>

<!-- PAGE CAMERA (between login and start) -->
<div id="cameraSetup" class="page">
  <div class="header-logos">
    <img src="{{ url_for('static', filename='logo-crossing.png') }}">
    <img src="{{ url_for('static', filename='logo-UT.png') }}">
  </div>

  <h1 class="title" style="font-size: 28px;">Camera</h1>
  <p>Select the camera to use. A preview is shown below.</p>

  <div class="camera-wrap">
    <div class="camera-row">
      <label for="cameraSelect" style="font-size: 14px; color:#333;">Device:</label>
      <select id="cameraSelect"></select>
    </div>

    <div class="camera-row">
      <label for="cameraIndexSelect" style="font-size: 14px; color:#333;">Backend camera:</label>
      <select id="cameraIndexSelect"></select>
    </div>
    <video id="cameraPreview" class="camera-video" autoplay playsinline muted></video>

    <div id="cameraHint" style="font-size: 12px; color:#666; text-align:center;"></div>

    <div class="camera-row" style="margin-top: 6px;">
      <button class="start-button" style="font-size:16px; padding:10px 18px;" onclick="continueAfterCamera()">Continue</button>
    </div>
  </div>
</div>

<!-- PAGE USER INFO (after camera) -->
<div id="userInfo" class="page">
  <div class="header-logos">
    <img src="{{ url_for('static', filename='logo-crossing.png') }}">
    <img src="{{ url_for('static', filename='logo-UT.png') }}">
  </div>

  <h1 class="title" style="font-size: 28px; text-align:center;">Information</h1>
  <p style="text-align:center;">Please fill in these fields (they may be shown in your results).</p>

  <div style="display:flex; flex-direction:column; gap:12px; align-items:center; margin-top: 18px;">
    <div style="width: 100%; max-width: 420px;">
      <label for="ageInput" style="display:block; font-size: 13px; color:#333; margin-bottom:4px;">Age</label>
      <input id="ageInput" type="number" min="0" max="120" placeholder="e.g., 27"
             style="width:100%; font-size:16px; padding:10px; border-radius:8px; border:1px solid #ccc;" />
    </div>

    <div style="width: 100%; max-width: 420px;">
      <label for="workHoursInput" style="display:block; font-size: 13px; color:#333; margin-bottom:4px;">Consecutive work hours</label>
      <input id="workHoursInput" type="number" min="0" max="24" step="0.5" placeholder="e.g., 6"
             style="width:100%; font-size:16px; padding:10px; border-radius:8px; border:1px solid #ccc;" />
    </div>

    <div style="width: 100%; max-width: 420px;">
      <label for="tirednessInput" style="display:block; font-size: 13px; color:#333; margin-bottom:4px;">Tiredness level (1-10): <span id="tirednessValue">5</span></label>
      <input id="tirednessInput" type="range" min="1" max="10" value="5" style="width:100%;" />
    </div>

    <button class="start-button" style="font-size:16px; padding:10px 18px;" onclick="continueAfterUserInfo()">Continue</button>
  </div>
</div>

<!-- PAGE QUESTIONS -->
<div id="questionPage" class="page">
    <div class="header-logos">
      <img src="{{ url_for('static', filename='logo-leia.png') }}">
      <img src="{{ url_for('static', filename='logo-UT.png') }}">
    </div>
  
    <div class="progress-container">
      <span id="questionCounter"></span>
      <div class="progress-bar">
        <div id="progressFill"></div>
      </div>
    </div>
  
    <!-- Badge type -->
    <span id="questionTypeBadge" class="question-type-badge"></span>

    <!-- Scenario layout (title+image left, description+prompt right) -->
    <div id="scenarioWrap">
      <div id="scenarioGrid">
        <div id="scenarioLeft">
          <h2 id="scenarioTitle"></h2>
          <img id="scenarioImage" src="" alt="">
        </div>
        <div id="scenarioRight">
          <p id="scenarioDescription"></p>
          <div id="scenarioRulesPrompt">What rules apply here?</div>
        </div>
      </div>
    </div>
  
    <!-- Image -->
    <img id="questionImage" src="" alt="">
  
    <h2 id="questionText"></h2>

    <!-- Zone réponse ouverte -->
    <div id="openAnswerZone" class="answer-row">
      <textarea id="input" placeholder="Type your answer here..."></textarea>
      <button id="openArrowButton" class="arrow-button" onclick="nextQuestion()" disabled>➜</button>
    </div>
  
    <!-- Zone QCM -->
    <div id="qcmZone" class="qcm-container">
      <div id="qcmChoices"></div>
      <button id="qcmValidateButton" class="validate-button" onclick="nextQuestion()" aria-label="Continue" title="Continue" disabled>➜</button>
    </div>
  </div>
  

<!-- PAGE FIN -->
<div id="end" class="page">
  <h2>Test completed</h2>
  <p>Thanks for participating.</p>
  <button class="finish-button" onclick="restart()">Back to login</button>
</div>

<!-- PAGE RÉSULTATS / FEEDBACK (avant fin) -->
<div id="review" class="page">
  <div class="review-header" style="text-align:center; margin-bottom:20px;">
    <h2 style="margin-bottom:10px;">Test results</h2>
    <div id="reviewResult" style="font-size:42px; font-weight:800; margin-bottom:6px;"></div>
    <div id="reviewPercentage" style="font-size:18px; color:#555;"></div>
    <div id="reviewTime" style="font-size:14px; color:#777;"></div>
  </div>

  <div id="reviewMeta" style="display:none;"></div>

  <div id="chartsWrap" style="margin-top:16px; display:grid; gap:14px;">
    <div class="chart-card">
      <h3>Answer breakdown</h3>
      <div class="chart-canvas"><canvas id="pieChart"></canvas></div>
    </div>
    <div class="chart-card">
      <h3>Grade & time per question</h3>
      <div class="chart-canvas"><canvas id="lineChart"></canvas></div>
    </div>
  </div>

  <p id="reviewStatus">Grading in progress…</p>
  <div id="reviewContent" style="margin-top: 20px;"></div>

  <div style="display:flex; gap:10px; justify-content:center; margin-top:20px; flex-wrap:wrap;">
    <button id="reviewDetails" class="finish-button" onclick="showDetails()" disabled>Details</button>
    <button id="reviewContinue" class="finish-button" onclick="goEnd()" disabled>Continue</button>
  </div>
</div>

<!-- PAGE DÉTAILS -->
<div id="details" class="page">
  <div class="header-logos">
    <img src="{{ url_for('static', filename='logo-leia.png') }}">
    <img src="{{ url_for('static', filename='logo-UT.png') }}">
  </div>

  <h2 style="text-align:center; margin-bottom:16px;">Answer review</h2>

  <div id="detailsNav" class="details-nav" style="display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-bottom:16px;"></div>

  <div class="details-content">
    <div class="details-column">
      <h3>Question</h3>
      <p id="detailsQuestion" style="white-space:pre-line;"></p>
      <img id="detailsImage" style="display:none; width:100%; margin-top:10px; border-radius:10px;" />
    </div>

    <div class="details-column">
      <h3>Your answer</h3>
      <p id="detailsUserAnswer" style="white-space:pre-line;"></p>

      <div id="detailsExpectedWrap">
        <h4 id="detailsExpectedLabel" style="margin-top:16px;">Expected answer</h4>
        <p id="detailsExpectedAnswer" style="white-space:pre-line;"></p>
      </div>
    </div>

    <div class="details-column">
      <h3>Result</h3>
      <div id="detailsStatus" style="display:inline-block; padding:6px 10px; border-radius:999px; font-weight:700;" ></div>
      <p style="margin-top:12px;"><b>Grade:</b> <span id="detailsGrade"></span></p>
      <p style="margin-top:12px;"><b>Time spent:</b> <span id="detailsTime"></span></p>
      <p style="margin-top:12px;" id="detailsExplanation"></p>
    </div>
  </div>

  <div style="margin-top:18px; text-align:center;">
    <button class="finish-button" onclick="showPage('review')">Back to results</button>
  </div>
</div>

<!-- Charts are best-effort (page still works without internet). -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  // Questions are served by the backend.
  let totalQuestions = 0;
  let currentQuestionData = null;
  let testId = null;
  let userName = "";
  let gradingPollTimer = null;
  let backgroundPollingActive = false;
  let answersSubmittedCount = 0;

  // Prefetch quiz right after login.
  let prefetchedTestId = null;
  let prefetchedTotal = 0;

  // Camera
  let cameraStream = null;
  let selectedCameraIndex = null;
  let selectedCameraDeviceId = null;
  let selectedCameraLabel = null;

  // User info (post-camera)
  let userMeta = {};
  let userMetaSent = false;
  let userProfile = null;

  let currentQuestion = 0;
  let questionStartTime = 0;
  let testStartTime = 0;
  let keystrokes = [];
  const results = [];

  const questionTypeBadge = document.getElementById("questionTypeBadge");
  const openAnswerZone = document.getElementById("openAnswerZone");
  const qcmZone = document.getElementById("qcmZone");
  const qcmChoices = document.getElementById("qcmChoices");
  const openArrowButton = document.getElementById("openArrowButton");
  const qcmValidateButton = document.getElementById("qcmValidateButton");
  
  let selectedQcmIndex = -1;

  const input = document.getElementById("input");
  const questionText = document.getElementById("questionText");
  const questionImage = document.getElementById("questionImage");
  const scenarioWrap = document.getElementById("scenarioWrap");
  const scenarioTitle = document.getElementById("scenarioTitle");
  const scenarioImage = document.getElementById("scenarioImage");
  const scenarioDescription = document.getElementById("scenarioDescription");
  const scenarioRight = document.getElementById("scenarioRight");
  const scenarioRulesPrompt = document.getElementById("scenarioRulesPrompt");
  const progressFill = document.getElementById("progressFill");
  const questionCounter = document.getElementById("questionCounter");
  const loadingOverlay = document.getElementById("loading");
  const loadingText = document.getElementById("loadingText");
  const gradingIndicator = document.getElementById("gradingIndicator");
  const nameInput = document.getElementById("nameInput");
  // Valider avec la touche Entrée sur le champ nom
  if (nameInput) {
    nameInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        confirmName();
      }
    });
  }
  const reviewStatus = document.getElementById("reviewStatus");
  const reviewContent = document.getElementById("reviewContent");
  const reviewContinue = document.getElementById("reviewContinue");
  const reviewDetails = document.getElementById("reviewDetails");
  const reviewResult = document.getElementById("reviewResult");
  const reviewPercentage = document.getElementById("reviewPercentage");
  const reviewTime = document.getElementById("reviewTime");
  const cameraSelect = document.getElementById("cameraSelect");
  const cameraIndexSelect = document.getElementById("cameraIndexSelect");
  const cameraPreview = document.getElementById("cameraPreview");
  const cameraHint = document.getElementById("cameraHint");
  const ageInput = document.getElementById("ageInput");
  const workHoursInput = document.getElementById("workHoursInput");
  const tirednessInput = document.getElementById("tirednessInput");
  const tirednessValue = document.getElementById("tirednessValue");
  const reviewMeta = document.getElementById("reviewMeta");

  const DEFAULT_LOADING_TEXT = "Loading…";
  const LLM_GENERATION_ETA_SECONDS = 30;
  const GRADING_SECONDS_PER_ANSWER = 10;

  function formatEta(seconds) {
    const s = Math.max(0, Math.floor(Number(seconds) || 0));
    const m = Math.floor(s / 60);
    const r = s % 60;
    if (m <= 0) return `${r}s~`;
    return `${m}m${String(r).padStart(2, "0")}s~`;
  }

  function setLoading(isLoading, message) {
    if (loadingText) {
      if (isLoading) {
        const msg = (typeof message === "string" && message.trim()) ? message : DEFAULT_LOADING_TEXT;
        loadingText.textContent = msg;
      } else {
        loadingText.textContent = "";
      }
    }

    if (isLoading) {
      loadingOverlay.classList.add("active");
      loadingOverlay.setAttribute("aria-hidden", "false");
    } else {
      loadingOverlay.classList.remove("active");
      loadingOverlay.setAttribute("aria-hidden", "true");
    }
  }

  function setGrading(isGrading) {
    if (isGrading) {
      gradingIndicator.classList.add("active");
      gradingIndicator.setAttribute("aria-hidden", "false");
    } else {
      gradingIndicator.classList.remove("active");
      gradingIndicator.setAttribute("aria-hidden", "true");
    }
  }

  function setGradingText(text) {
    const el = document.getElementById("gradingIndicator");
    if (!el) return;
    const label = el.querySelector("div:last-child");
    if (label) label.textContent = text;
  }

  function showPage(id) {
    document.querySelectorAll(".page").forEach(p => {
      p.classList.remove("active");
      p.style.display = "none";
    });
    const el = document.getElementById(id);
    if (!el) return;
    el.classList.add("active");
    el.style.display = "block";

    if (id === "home") {
      loadHistory();
    }
  }

  // Force initial page state on first load.
  document.addEventListener("DOMContentLoaded", () => {
    showPage("identify");
    if (nameInput) nameInput.focus();

    if (tirednessInput && tirednessValue) {
      tirednessInput.addEventListener("input", () => {
        tirednessValue.textContent = String(tirednessInput.value || "");
      });
    }
  });

  function _cameraPrefsKey() {
    return userName ? `fatigue_camera_prefs__${userName}` : null;
  }

  function loadSavedCameraPrefs() {
    try {
      const key = _cameraPrefsKey();
      if (!key) return;
      const raw = localStorage.getItem(key);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      // Important: avoid Number(null) => 0 which would incorrectly be treated as a valid index.
      if (
        parsed
        && parsed.camera_index !== null
        && parsed.camera_index !== undefined
        && parsed.camera_index !== ""
        && Number.isFinite(Number(parsed.camera_index))
      ) {
        selectedCameraIndex = Number(parsed.camera_index);
      }
      if (parsed && parsed.camera_device_id) {
        selectedCameraDeviceId = String(parsed.camera_device_id);
      }
      if (parsed && parsed.camera_label) {
        selectedCameraLabel = String(parsed.camera_label);
      }
    } catch (e) {
      // best-effort
    }
  }

  function saveCameraPrefs() {
    try {
      const key = _cameraPrefsKey();
      if (!key) return;
      const payload = {
        camera_index: Number.isFinite(selectedCameraIndex) ? selectedCameraIndex : null,
        camera_device_id: selectedCameraDeviceId ? String(selectedCameraDeviceId) : null,
        camera_label: selectedCameraLabel ? String(selectedCameraLabel) : null,
        saved_at: new Date().toISOString(),
      };
      localStorage.setItem(key, JSON.stringify(payload));
    } catch (e) {
      // best-effort
    }
  }

  async function fetchUserProfile() {
    if (!userName) return null;
    try {
      const r = await fetch(`/api/user_profile/${encodeURIComponent(userName)}`);
      const d = await r.json();
      if (!d || !d.ok) return null;
      userProfile = d.profile || null;

      // Only fill missing values from the backend profile (localStorage wins).
      if (userProfile) {
        if (
          !Number.isFinite(selectedCameraIndex)
          && userProfile.camera_index !== null
          && userProfile.camera_index !== undefined
          && userProfile.camera_index !== ""
          && Number.isFinite(Number(userProfile.camera_index))
        ) {
          selectedCameraIndex = Number(userProfile.camera_index);
        }
        if (!selectedCameraDeviceId && userProfile.camera_device_id) {
          selectedCameraDeviceId = String(userProfile.camera_device_id);
        }
        if (!selectedCameraLabel && userProfile.camera_label) {
          selectedCameraLabel = String(userProfile.camera_label);
        }
      }

      return userProfile;
    } catch (e) {
      console.warn("user_profile error:", e);
      return null;
    }
  }

  function applyProfileToUserInfoForm() {
    if (!userProfile || !ageInput) return;
    const current = String(ageInput.value || "").trim();
    if (current) return;

    const age = userProfile.age;
    if (age !== null && age !== undefined && Number.isFinite(Number(age))) {
      ageInput.value = String(Number(age));
    }
  }

  async function confirmName() {
    const nm = (nameInput && nameInput.value ? nameInput.value : "").trim();
    if (!nm) {
      alert("Please enter your name");
      return;
    }

    try {
      const resp = await fetch("/api/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: nm })
      });
      const data = await resp.json();
      if (!data.ok) {
        alert(data.error || "Login error");
        return;
      }
      userName = data.name;

      // Reset cached camera selection when switching users.
      selectedCameraIndex = null;
      selectedCameraDeviceId = null;
      selectedCameraLabel = null;
      userProfile = null;

      // Try to reuse previously chosen camera (localStorage first, then DB profile).
      loadSavedCameraPrefs();
      await fetchUserProfile();

      // If we already know the backend camera index, skip camera setup.
      if (Number.isFinite(selectedCameraIndex)) {
        showPage("home");
        return;
      }

      showPage("cameraSetup");
      await initCameraSetup();
    } catch (e) {
      console.error(e);
      alert("Login error");
    }
  }

  async function loadHistory() {
    const tbody = document.getElementById("historyTableBody");
    const tableWrapper = document.getElementById("historyTableWrapper");
    const noHistoryMessage = document.getElementById("noHistoryMessage");
    const chartWrap = document.getElementById("historyChartWrap");
    if (!tbody || !tableWrapper || !noHistoryMessage) return;

    tbody.innerHTML = "";

    if (!userName) {
      tableWrapper.style.display = "none";
      noHistoryMessage.textContent = "Please log in.";
      noHistoryMessage.style.display = "block";
      return;
    }

    try {
      const compareMode = getCompareMode();
      const resp = await fetch(`/api/user_history/${encodeURIComponent(userName)}?limit=200`);
      const data = await resp.json();
      const history = data && data.ok ? (data.history || []) : [];
      const othersSeries = data && data.ok ? (data.others_series || []) : [];

      if (!history || history.length === 0) {
        tableWrapper.style.display = "none";
        noHistoryMessage.style.display = "block";
        if (chartWrap) chartWrap.style.display = "none";
        return;
      }

      tableWrapper.style.display = "block";
      noHistoryMessage.style.display = "none";
      if (chartWrap) chartWrap.style.display = "block";

      // Render chart (best-effort)
      try {
        renderHistoryChart(history, othersSeries, compareMode);
      } catch (e) {
        console.warn("history chart failed:", e);
      }

      history.slice(0, 50).forEach(item => {
        const tr = document.createElement("tr");

        const dt = item.date_time || "";
        const dateLabel = dt ? dt.replace("T", " ") : "—";
        const mf = (item.mental_fatigue !== null && item.mental_fatigue !== undefined) ? Number(item.mental_fatigue) : null;
        const pf = (item.physical_fatigue !== null && item.physical_fatigue !== undefined) ? Number(item.physical_fatigue) : null;

        tr.innerHTML = `
          <td>${escapeHtml(dateLabel)}</td>
          <td>${(mf !== null && Number.isFinite(mf)) ? escapeHtml(mf.toFixed(1) + "/100") : "—"}</td>
          <td>${(pf !== null && Number.isFinite(pf)) ? escapeHtml(pf.toFixed(1) + "/100") : "—"}</td>
        `;

        const sid = item.session_id;
        if (sid) {
          tr.style.cursor = "pointer";
          tr.title = "Open this session";
          tr.onclick = () => openSessionDetails(String(sid));
        }
        tbody.appendChild(tr);
      });
    } catch (e) {
      console.error("History load error:", e);
      tableWrapper.style.display = "none";
      noHistoryMessage.textContent = "Unable to load history.";
      noHistoryMessage.style.display = "block";
      if (chartWrap) chartWrap.style.display = "none";
    }
  }

  function getCompareMode() {
    const el = document.querySelector('input[name="compareMode"]:checked');
    return el ? String(el.value || "me") : "me";
  }

  let historyChartInstance = null;

  function renderHistoryChart(history, othersSeries, compareMode) {
    const canvas = document.getElementById("historyChart");
    const hint = document.getElementById("historyChartHint");
    const wrap = document.getElementById("historyChartWrap");
    if (!canvas || !wrap) return;
    if (typeof Chart === "undefined") {
      wrap.style.display = "none";
      return;
    }

    const sorted = [...history].reverse(); // oldest first

    // Keep the user's session points always; when comparing to others, align others'
    // daily mean onto each session timestamp (repeated per session day).
    const labels = sorted.map(s => {
      const dt = String(s.date_time || "");
      return dt ? dt.replace("T", " ") : "";
    });
    const mental = sorted.map(s => {
      const v = (s.mental_fatigue !== null && s.mental_fatigue !== undefined) ? Number(s.mental_fatigue) : null;
      return (v !== null && Number.isFinite(v)) ? v : null;
    });
    const physical = sorted.map(s => {
      const v = (s.physical_fatigue !== null && s.physical_fatigue !== undefined) ? Number(s.physical_fatigue) : null;
      return (v !== null && Number.isFinite(v)) ? v : null;
    });

    const datasets = [
      {
        label: "Mental fatigue (/100)",
        data: mental,
        borderColor: "#1976d2",
        backgroundColor: "rgba(25,118,210,0.12)",
        tension: 0.25,
        spanGaps: true,
      },
      {
        label: "Physical fatigue (/100)",
        data: physical,
        borderColor: "#c62828",
        backgroundColor: "rgba(198,40,40,0.10)",
        tension: 0.25,
        spanGaps: true,
      },
    ];

    if (compareMode === "others" && Array.isArray(othersSeries) && othersSeries.length) {
      const map = new Map(othersSeries.map(x => [String(x.date || ""), x]));
      const otherMental = sorted.map(s => {
        const dt = String(s.date_time || "");
        const day = dt ? dt.split("T", 1)[0] : "";
        const it = map.get(day);
        const v = it && it.mental !== null && it.mental !== undefined ? Number(it.mental) : null;
        return (v !== null && Number.isFinite(v)) ? v : null;
      });
      const otherPhysical = sorted.map(s => {
        const dt = String(s.date_time || "");
        const day = dt ? dt.split("T", 1)[0] : "";
        const it = map.get(day);
        const v = it && it.physical !== null && it.physical !== undefined ? Number(it.physical) : null;
        return (v !== null && Number.isFinite(v)) ? v : null;
      });
      datasets.push({
        label: "Others mean (mental)",
        data: otherMental,
        borderColor: "rgba(25,118,210,0.55)",
        borderDash: [6, 6],
        tension: 0.25,
        spanGaps: true,
      });
      datasets.push({
        label: "Others mean (physical)",
        data: otherPhysical,
        borderColor: "rgba(198,40,40,0.55)",
        borderDash: [6, 6],
        tension: 0.25,
        spanGaps: true,
      });
    }

    if (historyChartInstance) historyChartInstance.destroy();
    historyChartInstance = new Chart(canvas.getContext("2d"), {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive: true,
        plugins: { legend: { position: "bottom" } },
        scales: { y: { suggestedMin: 0, suggestedMax: 100 } },
      }
    });

    if (hint) {
      hint.textContent = (compareMode === "others")
        ? "Comparison: your sessions vs others' daily mean."
        : "Your scores over time.";
    }
  }

  async function openSessionDetails(sessionId) {
    if (!userName || !sessionId) return;
    try {
      setLoading(true, "Loading session…");
      const resp = await fetch(`/api/user_session/${encodeURIComponent(userName)}/${encodeURIComponent(sessionId)}`);
      const data = await resp.json();
      if (!data || !data.ok) {
        throw new Error((data && data.error) ? data.error : "Session load failed");
      }
      // Use the stored payload directly for the existing Details page renderer.
      lastResultsData = data.payload;
      showDetails();
    } catch (e) {
      console.error(e);
      alert("Unable to load this session.");
    } finally {
      setLoading(false);
    }
  }

  // Reload chart/table when toggling compare mode.
  document.addEventListener("change", (e) => {
    const t = e && e.target;
    if (t && t.name === "compareMode") {
      loadHistory();
    }
  });

  let prefetchPromise = null;

  async function prefetchQuiz() {
    if (!userName) return;
    try {
      const r = await fetch("/api/prefetch_test", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: userName, n: 4, difficulty: "easy" })
      });
      const d = await r.json();
      if (d && d.ok) {
        prefetchedTestId = d.test_id;
      } else {
        console.warn("prefetch_test failed:", d);
        prefetchedTestId = null;
      }
    } catch (e) {
      console.warn("prefetch_test error:", e);
      prefetchedTestId = null;
    }
  }

  async function waitForPrefetchReady() {
    if (!prefetchedTestId) return null;
    for (;;) {
      const r = await fetch(`/api/test_status/${prefetchedTestId}`);
      const d = await r.json();
      if (!d || !d.ok) {
        return null;
      }
      if (d.status === "ready") {
        prefetchedTotal = d.total || 0;
        return d;
      }
      if (d.status === "failed") {
        console.warn("prefetch failed:", d.error);
        return null;
      }

      // creating: update the big overlay text with a rough ETA + retry count.
      const attempt = Number.isFinite(d.attempt) ? Number(d.attempt) : 0;
      const maxAttempts = Number.isFinite(d.max_attempts) ? Number(d.max_attempts) : 0;
      let retryText = "";
      if (attempt > 1) {
        retryText = maxAttempts > 0 ? ` (retry ${attempt}/${maxAttempts})` : ` (retry ${attempt})`;
      }
      setLoading(true, `LLM generating…${retryText} • ETA ${formatEta(LLM_GENERATION_ETA_SECONDS)}`);

      // creating
      await new Promise(res => setTimeout(res, 300));
    }
  }

  async function initCameraSetup() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      if (cameraHint) cameraHint.textContent = "Camera not available in this browser.";
      return;
    }

    try {
      // Request permission first so device labels appear.
      const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      // Stop immediately; we will reopen with selected device.
      tmp.getTracks().forEach(t => t.stop());
    } catch (e) {
      if (cameraHint) cameraHint.textContent = "Camera permission denied (you can still continue).";
      return;
    }

    await refreshCameraDeviceList();
    await refreshBackendCameraIndexList();

    if (cameraSelect) {
      cameraSelect.onchange = async () => {
        selectedCameraDeviceId = cameraSelect.value || null;
        selectedCameraLabel = (cameraSelect.selectedIndex >= 0 && cameraSelect.options[cameraSelect.selectedIndex])
          ? cameraSelect.options[cameraSelect.selectedIndex].textContent
          : null;
        saveCameraPrefs();
        await startCameraPreview(cameraSelect.value);
      };

      // Try to restore previously selected device.
      if (selectedCameraDeviceId && cameraSelect.querySelector(`option[value="${CSS.escape(selectedCameraDeviceId)}"]`)) {
        cameraSelect.value = selectedCameraDeviceId;
      }

      // Autostart selected device if any.
      if (cameraSelect.value) {
        selectedCameraDeviceId = cameraSelect.value || null;
        selectedCameraLabel = (cameraSelect.selectedIndex >= 0 && cameraSelect.options[cameraSelect.selectedIndex])
          ? cameraSelect.options[cameraSelect.selectedIndex].textContent
          : null;
        await startCameraPreview(cameraSelect.value);
      } else if (cameraSelect.options.length > 0) {
        // fallback to first device
        selectedCameraDeviceId = cameraSelect.options[0].value || null;
        selectedCameraLabel = cameraSelect.options[0].textContent || null;
        cameraSelect.value = selectedCameraDeviceId || "";
        if (cameraSelect.value) {
          await startCameraPreview(cameraSelect.value);
        }
      }
    }
  }

  async function refreshBackendCameraIndexList() {
    if (!cameraIndexSelect) return;
    cameraIndexSelect.innerHTML = "";

    try {
      const r = await fetch(`/api/video/cameras?max_index=6`);
      const d = await r.json();
      const cams = (d && d.ok && Array.isArray(d.cameras)) ? d.cameras : [];

      if (!cams.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "None";
        cameraIndexSelect.appendChild(opt);
        selectedCameraIndex = null;
        return;
      }

      cams.forEach((idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = `Index ${idx}`;
        cameraIndexSelect.appendChild(opt);
      });

      cameraIndexSelect.onchange = () => {
        selectedCameraIndex = cameraIndexSelect.value !== "" ? Number(cameraIndexSelect.value) : null;
        saveCameraPrefs();
      };

      // Try to restore previously selected backend index.
      if (Number.isFinite(selectedCameraIndex)) {
        const desired = String(selectedCameraIndex);
        if (cameraIndexSelect.querySelector(`option[value="${CSS.escape(desired)}"]`)) {
          cameraIndexSelect.value = desired;
        }
      }

      selectedCameraIndex = cameraIndexSelect.value !== "" ? Number(cameraIndexSelect.value) : null;
    } catch (e) {
      console.warn("backend camera list error:", e);
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Unavailable";
      cameraIndexSelect.appendChild(opt);
      selectedCameraIndex = null;
    }
  }

  async function refreshCameraDeviceList() {
    if (!cameraSelect) return;
    cameraSelect.innerHTML = "";
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videos = devices.filter(d => d.kind === "videoinput");

    videos.forEach((d, idx) => {
      const opt = document.createElement("option");
      opt.value = d.deviceId;
      opt.textContent = d.label || `Camera ${idx + 1}`;
      cameraSelect.appendChild(opt);
    });

    if (cameraHint) {
      cameraHint.textContent = videos.length
        ? "Select a camera if needed."
        : "No camera detected (you can still continue).";
    }
  }

  async function startCameraPreview(deviceId) {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;

    // Stop previous stream.
    if (cameraStream) {
      cameraStream.getTracks().forEach(t => t.stop());
      cameraStream = null;
    }

    const constraints = deviceId
      ? { video: { deviceId: { exact: deviceId } }, audio: false }
      : { video: true, audio: false };

    try {
      cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
      if (cameraPreview) cameraPreview.srcObject = cameraStream;
      if (cameraHint) cameraHint.textContent = "Camera preview active.";
    } catch (e) {
      console.warn("startCameraPreview error:", e);
      if (cameraHint) cameraHint.textContent = "Unable to start the camera (you can still continue).";
    }
  }

  function stopCameraPreview() {
    try {
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
      }
      if (cameraPreview) cameraPreview.srcObject = null;
    } catch (e) {
      // best-effort
    }
  }

  function continueAfterCamera() {
    if (cameraSelect && cameraSelect.value) {
      selectedCameraDeviceId = cameraSelect.value || null;
      selectedCameraLabel = (cameraSelect.selectedIndex >= 0 && cameraSelect.options[cameraSelect.selectedIndex])
        ? cameraSelect.options[cameraSelect.selectedIndex].textContent
        : null;
    }

    if (cameraIndexSelect && cameraIndexSelect.value !== "") {
      selectedCameraIndex = Number(cameraIndexSelect.value);
    }
    saveCameraPrefs();
    showPage("home");
  }

  async function postMetaIfPossible() {
    const id = testId || prefetchedTestId;
    if (!id) return;
    if (!userMeta || Object.keys(userMeta).length === 0) return;
    if (userMetaSent) return;
    try {
      const resp = await fetch(`/api/test_meta/${id}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ meta: userMeta })
      });
      const data = await resp.json();
      if (data && data.ok) {
        userMetaSent = true;
      } else {
        console.warn("test_meta failed:", data);
      }
    } catch (e) {
      console.warn("test_meta error:", e);
    }
  }

  async function continueAfterUserInfo() {
    const age = ageInput && ageInput.value !== "" ? Number(ageInput.value) : null;
    const workHours = workHoursInput && workHoursInput.value !== "" ? Number(workHoursInput.value) : null;
    const tired = tirednessInput ? Number(tirednessInput.value) : null;

    // Camera meta: prefer remembered selection (works even if camera setup page was skipped).
    const camDeviceId = selectedCameraDeviceId || (cameraSelect && cameraSelect.value ? cameraSelect.value : null);
    const camLabel = selectedCameraLabel || ((cameraSelect && cameraSelect.selectedIndex >= 0 && cameraSelect.options[cameraSelect.selectedIndex])
      ? cameraSelect.options[cameraSelect.selectedIndex].textContent
      : null);

    const camIndex = Number.isFinite(selectedCameraIndex)
      ? selectedCameraIndex
      : ((cameraIndexSelect && cameraIndexSelect.value !== "") ? Number(cameraIndexSelect.value) : null);

    // Persist latest selections for next evaluation.
    selectedCameraDeviceId = camDeviceId;
    selectedCameraLabel = camLabel;
    selectedCameraIndex = Number.isFinite(camIndex) ? camIndex : null;
    saveCameraPrefs();

    userMeta = {
      age: Number.isFinite(age) ? age : null,
      consecutive_work_hours: Number.isFinite(workHours) ? workHours : null,
      tiredness: Number.isFinite(tired) ? tired : null,
      camera_device_id: camDeviceId,
      camera_label: camLabel,
      camera_index: Number.isFinite(camIndex) ? camIndex : null
    };

    // Ensure we have a prefetched test to attach meta + start questions.
    try {
      setLoading(true, "LLM generating…");
      if (prefetchPromise) {
        await prefetchPromise;
      }
      if (!prefetchedTestId) {
        prefetchPromise = prefetchQuiz();
        await prefetchPromise;
      }
      await postMetaIfPossible();

      const st = await waitForPrefetchReady();
      if (!st || !st.ok || st.status !== "ready") {
        throw new Error("Quiz generation not ready");
      }

      // Start the actual test now.
      testId = prefetchedTestId;
      totalQuestions = prefetchedTotal || st.total || 0;

      // Start backend recording now that quiz is ready.
      try {
        // Important (Windows): release the browser webcam stream so OpenCV can open the camera.
        stopCameraPreview();
        await fetch(`/api/video/start/${testId}`, { method: "POST" });
      } catch (e) {
        console.warn("video start failed:", e);
      }

      currentQuestion = 0;
      testStartTime = Date.now();
      results.length = 0;
      answersSubmittedCount = 0;
      backgroundPollingActive = false;

      showPage("questionPage");
      await loadQuestion(0);
    } catch (e) {
      console.error(e);
      alert("Quiz generation error");
      showPage("home");
    } finally {
      setLoading(false);
    }
  }

  async function startTest() {
    // Requirement: start generating quiz in background on click,
    // and show the info questionnaire immediately after the click.
    prefetchedTestId = null;
    prefetchedTotal = 0;
    testId = null;
    userMetaSent = false;
    prefetchPromise = prefetchQuiz();
    showPage("userInfo");
    applyProfileToUserInfoForm();
  }

  async function loadQuestion(index) {
    const qResp = await fetch(`/api/question/${testId}/${index}`);
    const qData = await qResp.json();
    if (qData.done) {
      await submitAndShowReview();
      return;
    }
    currentQuestionData = qData;
    showQuestionFromData(qData);
  }

    function showQuestionFromData(qData) {
        input.value = "";
        keystrokes = [];
        selectedQcmIndex = -1;

        const isQcm = qData.type === "qcm";
        const isScenario = qData.type === "scenario";

        // Scenario: show split title/description and image on the left.
        if (isScenario) {
          const t = (qData.title !== undefined && qData.title !== null) ? String(qData.title) : "";
          const d = (qData.description !== undefined && qData.description !== null) ? String(qData.description) : "";
          const fallback = String(qData.question || "");
          const titleText = t || fallback.split("\n\n")[0] || "";
          const descText = d || (fallback.includes("\n\n") ? fallback.split("\n\n").slice(1).join("\n\n") : "");

          if (scenarioWrap) scenarioWrap.style.display = "block";
          if (scenarioTitle) scenarioTitle.textContent = titleText;
          if (scenarioDescription) scenarioDescription.textContent = descText;

          if (scenarioImage) {
            if (qData.image) {
              scenarioImage.src = qData.image;
              scenarioImage.style.display = "block";
            } else {
              scenarioImage.style.display = "none";
            }
          }

          if (questionText) questionText.style.display = "none";
          if (questionImage) questionImage.style.display = "none";
          if (scenarioRulesPrompt) scenarioRulesPrompt.style.display = "block";

          // Put the answer box under the scenario prompt (right column).
          if (scenarioRight && openAnswerZone && openAnswerZone.parentElement !== scenarioRight) {
            scenarioRight.appendChild(openAnswerZone);
          }
        } else {
          if (scenarioWrap) scenarioWrap.style.display = "none";
          if (scenarioRulesPrompt) scenarioRulesPrompt.style.display = "none";
          if (questionText) {
            questionText.style.display = "block";
            questionText.textContent = qData.question || "";
          }

          // Ensure the answer box returns to the main flow for non-scenarios.
          const questionPageEl = document.getElementById("questionPage");
          if (questionPageEl && openAnswerZone && qcmZone && openAnswerZone.parentElement !== questionPageEl) {
            questionPageEl.insertBefore(openAnswerZone, qcmZone);
          }
        }

        // Badge type
        if (isQcm) {
            questionTypeBadge.textContent = "QCM";
            questionTypeBadge.className = "question-type-badge badge-qcm";
        } else if (isScenario) {
          questionTypeBadge.textContent = "Scenario";
          questionTypeBadge.className = "question-type-badge badge-open";
        } else {
            questionTypeBadge.textContent = "Open question";
            questionTypeBadge.className = "question-type-badge badge-open";
        }

        // Image
        if (!isScenario) {
          if (qData.image) {
            questionImage.src = qData.image;
            questionImage.style.display = "block";
          } else {
            questionImage.style.display = "none";
          }
        }

        // Zones réponse
        if (isQcm) {
            openAnswerZone.style.display = "none";
            qcmZone.style.display = "flex";
            renderQcmChoices(qData.choices || []);
            qcmValidateButton.disabled = true;
        } else {
            openAnswerZone.style.display = "flex";
            qcmZone.style.display = "none";
            openArrowButton.disabled = true;
        }

        questionStartTime = Date.now();
        const total = qData.total || totalQuestions || 1;
        const idx = (qData.index ?? currentQuestion) + 1;
        questionCounter.textContent = `Question ${idx} / ${total}`;
        progressFill.style.width = `${(idx / total) * 100}%`;

        showPage("questionPage");
    }

    function renderQcmChoices(choices) {
  const letters = ['A','B','C','D','E','F'];
  qcmChoices.innerHTML = "";

  choices.forEach((choice, index) => {
    const div = document.createElement("div");
    div.className = "qcm-choice";
    div.innerHTML = `
      <span class="choice-letter">${letters[index]}</span>
      <span>${choice}</span>
    `;
    div.onclick = () => selectQcmChoice(index);
    qcmChoices.appendChild(div);
  });
}

function selectQcmChoice(index) {
  selectedQcmIndex = index;

  keystrokes.push({
    touche: `choice_${index}`,
    temps: Date.now() - questionStartTime
  });

  document.querySelectorAll(".qcm-choice").forEach((el, i) => {
    el.classList.toggle("selected", i === index);
  });

  qcmValidateButton.disabled = false;
}


  input.addEventListener("input", () => {
    openArrowButton.disabled = input.value.trim() === "";
  });

  input.addEventListener("keydown", (event) => {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      if (!openArrowButton.disabled) nextQuestion();
    }

    keystrokes.push({
      touche: event.key,
      temps: Date.now() - questionStartTime
    });
  });

  async function submitAnswerIncremental(index, answerObj) {
    if (!testId) return;
    const idx = Number.isFinite(index) ? index : 0;
    try {
      const resp = await fetch(`/api/answer/${testId}/${idx}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(answerObj)
      });
      const data = await resp.json();
      if (!data.ok) {
        console.warn("Incremental submit failed:", data.error || data);
      } else {
        answersSubmittedCount = Math.max(answersSubmittedCount, idx + 1);
        // Start background polling on first successful incremental submit.
        if (!backgroundPollingActive) {
          backgroundPollingActive = true;
          startPollingGrading({ mode: "background" });
        }
      }
    } catch (e) {
      console.warn("Incremental submit error:", e);
    }
  }

  async function nextQuestion() {
    const timeSpent = Date.now() - questionStartTime;
    const isQcm = currentQuestionData.type === "qcm";

    const answerObj = {
    question: currentQuestionData.question,
    type: currentQuestionData.type,
    answer: isQcm ? currentQuestionData.choices[selectedQcmIndex] : input.value,
    selected_index: isQcm ? selectedQcmIndex : null,
    timeSpent: timeSpent,
    keystrokes: keystrokes
    };

    results.push(answerObj);

    // Submit each answer immediately for grading (non-blocking).
    const qIndex = (currentQuestionData && Number.isFinite(currentQuestionData.index))
      ? currentQuestionData.index
      : currentQuestion;
    submitAnswerIncremental(qIndex, answerObj);

    currentQuestion++;
    try {
      setLoading(true);
      await loadQuestion(currentQuestion);
    } finally {
      setLoading(false);
    }
  }

  async function submitAndShowReview() {
    const totalTestTime = Date.now() - testStartTime;
    const payload = { totalTestTime: totalTestTime, results: results, name: userName };

    showPage("review");
    reviewStatus.textContent = "Submitting answers…";
    reviewContent.innerHTML = "";
    reviewContinue.disabled = true;

    try {
      setGrading(true);

      // Stop backend recording on final submission.
      try {
        const vr = await fetch(`/api/video/stop/${testId}`, { method: "POST" });
        const vd = await vr.json();
        if (vd && vd.ok && vd.summary) {
          userMeta = userMeta || {};
          userMeta.video = vd.summary;
        }
      } catch (e) {
        console.warn("video stop failed:", e);
      }

      const submitResp = await fetch(`/api/submit/${testId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const submitData = await submitResp.json();
      if (!submitData.ok) {
        throw new Error(submitData.error || "submit failed");
      }
      reviewStatus.textContent = "Grading in progress…";
      startPollingGrading({ mode: "review" });
    } catch (e) {
      console.error(e);
      setGrading(false);
      reviewStatus.textContent = "Submit/grading error.";
    }
  }

  function startPollingGrading(opts) {
    const mode = (opts && opts.mode) ? opts.mode : "review"; // 'review' | 'background'
    if (gradingPollTimer) {
      clearInterval(gradingPollTimer);
      gradingPollTimer = null;
    }

    gradingPollTimer = setInterval(async () => {
      try {
        const st = await fetch(`/api/grading_status/${testId}`);
        const stData = await st.json();
        if (!stData.ok) return;

        // Update the corner indicator during the whole test.
        if (stData.status === "processing" || stData.status === "queued") {
          setGrading(true);
          const done = stData.progress || 0;
          const denom = answersSubmittedCount || stData.total || totalQuestions || 0;
          const remaining = Math.max(0, (denom || 0) - (done || 0));
          const eta = formatEta(remaining * GRADING_SECONDS_PER_ANSWER);
          setGradingText(`Grading… (${done}/${denom}) • ETA ${eta}`);
        }

        if (stData.status === "processing" || stData.status === "queued") {
          if (mode === "review") {
            reviewStatus.textContent = `Grading… (${stData.progress || 0}/${stData.total || totalQuestions})`;
          }
          return;
        }

        if (stData.status === "done") {
          clearInterval(gradingPollTimer);
          gradingPollTimer = null;
          setGrading(false);
          setGradingText("Grading completed.");
          if (mode === "review") {
            await fetchAndRenderResults();
          }
          return;
        }

        if (stData.status === "failed") {
          clearInterval(gradingPollTimer);
          gradingPollTimer = null;
          setGrading(false);
          setGradingText("Grading failed.");
          if (mode === "review") {
            reviewStatus.textContent = stData.error ? `Error: ${stData.error}` : "Grading failed.";
          }
        }
      } catch (e) {
        console.error(e);
      }
    }, 1000);
  }

  async function fetchAndRenderResults() {
    const r = await fetch(`/api/grading_result/${testId}`);
    const data = await r.json();
    if (!data.ok) {
      reviewStatus.textContent = "Unable to fetch results.";
      return;
    }

    // Keep for details page.
    lastResultsData = data;

    const per = (data.grading && data.grading.per_question) ? data.grading.per_question : [];
    const answers = data.answers || [];
    const meta = data.meta || userMeta || {};
    const video = data.video || (meta && meta.video) || (userMeta && userMeta.video) || {};
    const fatigue = data.fatigue || {};

    // Charts (best-effort)
    try {
      renderCharts(data);
    } catch (e) {
      // ignore
    }

    // Header summary (result + percentage + time)
    try {
      let avg = (data.grading && (data.grading.average_score !== null && data.grading.average_score !== undefined)) ? Number(data.grading.average_score) : null;
      if (!(avg !== null && Number.isFinite(avg))) {
        // Fallback: compute from per-question score_total.
        let sum = 0;
        let cnt = 0;
        per.forEach(it => {
          const sc = (it && it.score_total !== null && it.score_total !== undefined) ? Number(it.score_total) : null;
          if (sc !== null && Number.isFinite(sc)) { sum += sc; cnt += 1; }
        });
        avg = cnt ? (sum / cnt) : null;
      }
      const pct = (avg !== null && Number.isFinite(avg)) ? Math.round((avg / 10) * 100) : null;

      let finalResult = "—";
      let cls = "";
      if (pct !== null) {
        if (pct < 50) { finalResult = "Not fit"; cls = "result-inapte"; }
        else if (pct < 75) { finalResult = "Caution"; cls = "result-attention"; }
        else { finalResult = "Fit"; cls = "result-apte"; }
      }

      if (reviewResult) {
        reviewResult.textContent = finalResult;
        reviewResult.className = cls;
      }
      if (reviewPercentage) {
        reviewPercentage.textContent = (pct === null) ? "" : `${pct}%`;
      }
      if (reviewTime) {
        const tt = data.totalTestTime;
        const ms = (tt !== null && tt !== undefined) ? Number(tt) : null;
        if (ms !== null && Number.isFinite(ms) && ms >= 0) {
          const minutes = Math.floor(ms / 60000);
          const seconds = Math.floor((ms % 60000) / 1000);
          reviewTime.textContent = `Total time: ${minutes}m ${seconds}s`;
        } else {
          reviewTime.textContent = "";
        }
      }
    } catch (e) {
      // best-effort
    }

    if (reviewMeta) {
      // Intentionally kept empty/hidden: removes debug-like meta output from the synthetic results page.
      reviewMeta.innerHTML = "";
    }
      if (reviewContent) {
        reviewContent.innerHTML = `
          <div style="padding:12px; border:1px solid #eee; border-radius:12px; background:#fff;">
            Question-by-question details (answer, expected answer, feedback) are available in <b>Details</b>.
          </div>
        `;
      }

    reviewStatus.textContent = "Grading completed.";
    reviewContinue.disabled = false;
    if (reviewDetails) reviewDetails.disabled = false;
  }

  let pieChartInstance = null;
  let lineChartInstance = null;

  function renderCharts(data) {
    const wrap = document.getElementById("chartsWrap");
    const pieEl = document.getElementById("pieChart");
    const lineEl = document.getElementById("lineChart");
    if (!wrap || !pieEl || !lineEl) return;

    if (typeof Chart === "undefined") {
      // Hide charts if Chart.js is unavailable.
      wrap.style.display = "none";
      return;
    }

    const per = (data.grading && Array.isArray(data.grading.per_question)) ? data.grading.per_question : [];
    const answers = Array.isArray(data.answers) ? data.answers : [];

    const scores = per.map(it => {
      const v = (it && it.score_total !== null && it.score_total !== undefined) ? Number(it.score_total) : null;
      return (v !== null && Number.isFinite(v)) ? v : 0;
    });

    const times = scores.map((_, i) => {
      const ms = (answers[i] && answers[i].timeSpent !== null && answers[i].timeSpent !== undefined) ? Number(answers[i].timeSpent) : null;
      return (ms !== null && Number.isFinite(ms) && ms >= 0) ? Math.round(ms / 1000) : 0;
    });

    const correct = scores.filter(s => s >= 10).length;
    const partial = scores.filter(s => s > 0 && s < 10).length;
    const incorrect = scores.filter(s => s <= 0).length;

    if (pieChartInstance) pieChartInstance.destroy();
    if (lineChartInstance) lineChartInstance.destroy();

    pieChartInstance = new Chart(pieEl.getContext("2d"), {
      type: "pie",
      data: {
        labels: ["Correct", "Partial", "Incorrect"],
        datasets: [{
          data: [correct, partial, incorrect],
          backgroundColor: ["#2e7d32", "#f9a825", "#c62828"],
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { position: "bottom" } }
      }
    });

    const labels = scores.map((_, i) => `Q${i + 1}`);
    lineChartInstance = new Chart(lineEl.getContext("2d"), {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Grade (/10)",
            data: scores,
            borderColor: "#1976d2",
            backgroundColor: "rgba(25,118,210,0.15)",
            tension: 0.25,
            yAxisID: "yScore",
          },
          {
            label: "Time (s)",
            data: times,
            borderColor: "#6a1b9a",
            backgroundColor: "rgba(106,27,154,0.12)",
            tension: 0.25,
            yAxisID: "yTime",
          },
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { position: "bottom" } },
        scales: {
          yScore: { position: "left", suggestedMin: 0, suggestedMax: 10 },
          yTime: { position: "right", grid: { drawOnChartArea: false }, suggestedMin: 0 },
        }
      }
    });
  }

  let lastResultsData = null;
  let currentDetailIndex = 0;

  function showDetails() {
    if (!lastResultsData) return;
    showPage("details");
    buildDetailsNav();
    showDetail(0);
  }

  function buildDetailsNav() {
    const nav = document.getElementById("detailsNav");
    if (!nav || !lastResultsData) return;
    nav.innerHTML = "";

    const per = (lastResultsData.grading && lastResultsData.grading.per_question) ? lastResultsData.grading.per_question : [];
    const total = per.length || ((lastResultsData.quiz && lastResultsData.quiz.length) ? lastResultsData.quiz.length : 0);

    function colorForScore(score) {
      const s = (score !== null && score !== undefined && Number.isFinite(Number(score))) ? Number(score) : null;
      if (s === null) return { bg: "#9e9e9e", fg: "#fff" };
      if (s >= 10) return { bg: "#2e7d32", fg: "#fff" }; // green
      if (s > 0) return { bg: "#f9a825", fg: "#fff" };  // orange
      return { bg: "#c62828", fg: "#fff" };             // red
    }

    for (let i = 0; i < total; i++) {
      const btn = document.createElement("button");
      btn.className = "details-dot";
      btn.type = "button";
      btn.textContent = String(i + 1);
      btn.setAttribute("aria-label", `Question ${i + 1}`);

      const g = per[i] || {};
      const sc = (g && g.score_total !== null && g.score_total !== undefined) ? Number(g.score_total) : null;
      const c = colorForScore(sc);
      btn.style.background = c.bg;
      btn.style.color = c.fg;

      btn.onclick = () => showDetail(i);
      nav.appendChild(btn);
    }
  }

  function showDetail(index) {
    if (!lastResultsData) return;
    currentDetailIndex = index;

    const quiz = Array.isArray(lastResultsData.quiz) ? lastResultsData.quiz : [];
    const answers = Array.isArray(lastResultsData.answers) ? lastResultsData.answers : [];
    const per = (lastResultsData.grading && Array.isArray(lastResultsData.grading.per_question)) ? lastResultsData.grading.per_question : [];

    const q = quiz[index] || {};
    const a = answers[index] || {};
    const g = per[index] || {};

    const sc = (g && g.score_total !== null && g.score_total !== undefined) ? Number(g.score_total) : null;

    const qText = (q && q.question) ? String(q.question) : "";
    const qImg = (q && q.image) ? String(q.image) : "";

    const detailsQuestion = document.getElementById("detailsQuestion");
    if (detailsQuestion) detailsQuestion.textContent = qText;

    const imgEl = document.getElementById("detailsImage");
    if (imgEl) {
      if (qImg) {
        imgEl.src = qImg;
        imgEl.style.display = "block";
      } else {
        imgEl.style.display = "none";
      }
    }

    const userAnswer = (a && a.answer) ? String(a.answer) : "(No answer)";
    const detailsUserAnswer = document.getElementById("detailsUserAnswer");
    if (detailsUserAnswer) detailsUserAnswer.textContent = userAnswer;

    // Expected answer (best-effort)
    let expected = "—";
    if (q && q.type === "qcm" && Array.isArray(q.choices) && q.correct_index !== null && q.correct_index !== undefined) {
      const ci = Number(q.correct_index);
      if (Number.isFinite(ci) && ci >= 0 && ci < q.choices.length) expected = String(q.choices[ci]);
    } else if (q && q.truth_answer) {
      expected = String(q.truth_answer);
    }
    const detailsExpectedAnswer = document.getElementById("detailsExpectedAnswer");
    if (detailsExpectedAnswer) detailsExpectedAnswer.textContent = expected;

    const expectedWrap = document.getElementById("detailsExpectedWrap");
    if (expectedWrap) {
      expectedWrap.style.display = (q && q.type === "scenario") ? "none" : "block";
    }

    const ms = (a && a.timeSpent !== null && a.timeSpent !== undefined) ? Number(a.timeSpent) : null;
    const detailsTime = document.getElementById("detailsTime");
    if (detailsTime) detailsTime.textContent = (ms !== null && Number.isFinite(ms)) ? `${Math.round(ms / 1000)} s` : "—";

    const detailsGrade = document.getElementById("detailsGrade");
    if (detailsGrade) {
      detailsGrade.textContent = (sc !== null && Number.isFinite(sc)) ? `${sc.toFixed(1)}/10` : "—";
    }

    const fb = (g && g.feedback) ? String(g.feedback) : "";
    const detailsExplanation = document.getElementById("detailsExplanation");
    if (detailsExplanation) detailsExplanation.textContent = fb;

    const detailsStatus = document.getElementById("detailsStatus");
    if (detailsStatus) {
      let label = "—";
      let bg = "#eee";
      let color = "#333";
      if (sc !== null && Number.isFinite(sc)) {
        if (sc >= 10) { label = "Correct"; bg = "#e8f5e9"; color = "#2e7d32"; }
        else if (sc > 0) { label = "Partial"; bg = "#fff8e1"; color = "#f9a825"; }
        else { label = "Incorrect"; bg = "#ffebee"; color = "#c62828"; }
      }
      detailsStatus.textContent = label;
      detailsStatus.style.background = bg;
      detailsStatus.style.color = color;
      detailsStatus.style.border = `1px solid ${color}`;
    }

    // active button
    const nav = document.getElementById("detailsNav");
    if (nav) {
      Array.from(nav.querySelectorAll("button")).forEach((b, i) => {
        if (i === index) b.classList.add("selected");
        else b.classList.remove("selected");
      });
    }
  }

  function escapeHtml(s) {
    return String(s || "").replace(/[&<>"]/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]));
  }

  function goEnd() {
    showPage("end");
  }

  function restart() {
    testId = null;
    userName = "";
    prefetchedTestId = null;
    prefetchedTotal = 0;
    prefetchPromise = null;
    userMeta = {};
    userMetaSent = false;
    if (nameInput) nameInput.value = "";

    if (cameraStream) {
      cameraStream.getTracks().forEach(t => t.stop());
      cameraStream = null;
    }
    if (cameraPreview) cameraPreview.srcObject = null;

    showPage("identify");
    if (nameInput) nameInput.focus();
  }

</script>
</body>
</html>
